### 一、rabbitmq介绍

消息队列在项目中应用很广，主要可完成项目中的应用解耦，消息异步，流量削峰等功能,

Rabbitmq基于erlang开发，安装部署简单，且性能强大，支持集群拓展，有web可视化界面

但是单纯性能来看比kafka弱太多，如果单纯的追求性能的话，推荐使用kafka，如果考虑综合能力，推荐rabbitmq

应用解耦：如项目在没有采用队列之间是紧耦合的，在一个用户注册的功能，当用户注册成功后会给用户发送注册成功的短信，发送注册成功的邮件，代码上肯定是依次执行，这就是紧耦合，带来的缺陷就是可能发送短信失败，导致发送邮件也无法发送，因为发短信异常了，在分布式服务框架下，项目和项目之间是松耦合的，有可能注册项目和短信邮件服务并不在一个项目机构中，无法直接调用，就可以采用队列，当用户注册成功后在控制层不在执行发送短信和邮件的方法了，而是将发送短信和邮件，作为消息发送到队列中，短信，邮件服务中项目中定义消费者，监听队列中的消息，当收到消息的时候，取出来，执行发送短信和邮件的代码，邮件和短信，都是独立的服务，因此，他们是并发执行的。好处就是，每个功能都是以消息的形式去运行的，当某个服务发生异常，或者失败时，不耽误其他服务的执行。

消息异步：在项目中如果某项功能执行时间过长，比如项目中进行一个商品更新，这个时候要修改数据库的数据，但是项目中，商品数据还有可能会存在其他数据层，redis，es,mogo中这个时候，这三个数据层也要进行响应的数据修改，如果同时操作多个数据层那么方法的效率就会变化，还有可能单点故障，所以我们直接修改mysql信息就好。然后将修改的动作发送到队列，其他数据层可以设置队列监听者，监听这个商品更新的队列，这个时候，在去执行各自的数据层更新，可以异步的执行，这样就可以保证方法的效率和健壮性

 

流量削峰：队列又称削峰填谷，作用就是把项目高峰期的压力，分散到项目的其他时间段去执行，常见功能就是电商项目中的抢购功能，还有12306的抢购功能，这些功能在一瞬间会产生大量的并发请求，最终还需要连接数据库进行数据修改，tomcat做集群可以成功接收这些请求，单台tomcat的并发量就可以达到500-1000，但数据库的连接数默认只有120左右，所以tomcat可以承受并发的压力，数据库却不行，这个时候可以将集中式的请求，存放到队列，提示前台加入抢购等结果就像，然后交由消费者项目监听这个消息，会依次执行，而不会并发执行，形成了排队的一个机制，请求执行完之后，可将结果由短信，邮件的形式通知到请求方

### 二、安装介绍

在linux进行安装

先安装erlang环境

在安装rabbit环境

开启web管理界面

然后在web界面创建用户，vhost 在将两者进行绑定，删除默认用户guest即可

### 三、Rabbitmq 7种消息类型

#### 1.简单消息类型

有三个角色，发送者p，队列q，消费者c

发送者向队列投递消息，指定队列名称和传输数据，队列接收存储消息，消费者监听队列的消息，有消息就接受消息去进行消息业务处理，处理完毕后，消息从队列中消失

优点：结构简单易用 实现了队列的过程，缺点：代码拓展性弱，接受消息不灵活，如果发送消息的频率过高，消费者会监听处理不过来，导致消息积压

#### 2.Work任务消息类型

有三个角色，发送者p，队列q，消费者c1 c1

发送者正常向队列投递消息，对列正常缓存消息，消费者可以设置多台，同时去监听一个队列，当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。

优点：使用任务消息类型，可以配置多台消费者，避免消息积压

缺点：代码拓展性弱，接受消息不灵活，

 

#### 发布订阅类型

跟上两个类型相比多了一个excange交换机 的概念

有四个角色，发送者p，交换机ex ，队列q，消费者c

发送者发送消息的时候，不在发送到队列，直接将消息发送到交换机，然后用交换机可以绑定多个队列，当交换机接受到消息时候，绑定到交换机的队列，都会接受到这个消息，从而可以完成不同的业务逻辑， 交换机只负责接受广播消息，不具备消息存储功能，需要队列绑定到交换机才能从交换机接受到消息

优点：方便拓展，广播端值广播消息，消费者队列可以设置一个或多个，增加新的业务消费者无需修改广播段代码

 

#### 3.Fanout是扇形交换机

交换机的一种，交换机创建的时候需要指定类型，fanout类型是交换机接受到消息的时候，将消息广播到所有队列，只要是绑定到交换机的队列都能接受到消息，这样发送者只能将消息发送到交换机，交换机来决定发送消息到哪个队列， 一个交换机可以广播消息到多个队列，一个队列也可以有哦多个消费者

 

#### 4.发布订阅类型-direct

在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。

在Direct模型下：

队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）

消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。

Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息

 

#### 5.发布订阅类型-topic

`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符

通配符规则：

 #：匹配一个或多个词

 *：匹配不多不少恰好1个词

 

#### 6.Rpc类型

以上五种模型，解决的都是单向传输问题。就是说，发送端发出消息后，不关心谁执行了消息，执行结果怎么样，这种行为是异步的，消费端接收到消息，执行后，通过ack机制，可以将执行结果发送给队列，而没有发送给发送端。大多数需求都是这样的

但如果需求比较特殊，就是 发送端，需要知道消息执行的结果，那么如何处理的，ack只能默认通知到队列，而不能通知到发送端，如果在需求中，发送者需要知道消息执行的结果来进行一些业务处理，那么就是使用rpc类型，在发送端发动消息时候同时发送一个队列过去，在发送端定义这个队列的消费者回调，在消费端接受传过来的队列，完成消费业务处理后，在传过来的队列发送回去，这样就完成了消息的回调，发送端可以知道消费者已经完成消息消费了

 

#### 7.确认类型

使用发布者确认来确保已发布的消息已安全到达代理。我们将介绍几种使用发布商确认并解释其优缺点的策略。

发送者发送消息到队列，但是具体发布成功与否，不能确认，所以mq提供了确认机制，发送完之后，可以调用api方法来确认此次发送消息是否成功。通过channel.confirmSelect开启确认模式通过waitForConfirms方法，确认消息是否发送成功，失败的时候可以进行一些额外容错处理

 

 

 

### 四、Rabbitmq在ssm项目中使用。

1:要安装erlang的环境，安装rabbitmq安装包，端口默认是15672，账号密码是guest，能够登陆成功就算安装成功

2：生产者如何发送消息到队列

在生产者项目中导入spring-ranbbit包，因为队列交由spring整合了，配置spring-producer.xml配置文件，这个xml 通过rabbit:connection-factory标签中配置队列的ip 端口 账号密码等，通过rabbit:template配置队列的模板工具类 使用 rabbit:queue配置队列的名称 是否持久化等，通过rabbit:direct-exchange配置交换机，最后在rabbit:bindings中配置队列的key 将队列和交换机绑定，在项目中用@autowire注入AmqpTemplate 这个队列的模板类，通过这个类的convertAndSend方法就可以发送消息了，调用后，可通过队列提供的web界面去查看，

2：消费者如果从队列监听消息并执行

在消费者项目中导入spring-rabbit包，配置spring-consumer.xml这是消费者配置文件，基本的配置和生产者差不多，使用rabbit:connection-factory配置连接工厂，使用bean配置实例化消费者类，消费者类需要实现MessageListener接口，重写onMessage方法，执行类使用rabbit:queue声明队列，使用rabbit:listener-container监听者 把消息和消息监听者去绑定一下，然后web.xml加载这个文件，会时时监听队列，这个时候有消息就会执行消费者类中的onMessage方法，当然之能依次执行，例如队列中有10个消息，一次只能拿一个执行，执行完这个才能执行下一个消息，当然rabbit有很好的容错机制，当方法执行错误时，发送异常，就是把消息重新发送到系列，等待下一次执行，如果想提高消费者的执行效率，也可通过部署多个消费者来执行这个消息,

### 五、Rabbitmq在boot项目中使用。

Springboot的技术栈默认提供了amqp的支持，已经整合的rabbitmq，我们直接使用就可以

Pom导入spring-boot-starter-amqp启动器，yml配置相关的ip，账号密码，vhost虚拟主机等信息

生产者直接注入amqpTemplate模板类，直接调用convertAndSend发送消息即可convertAndSend是重载方法，可以指定交换机，routingkey，message参数等

消费者需要定义队列，交换机， routing，交换机类型 ,持久化设置等参数，消费者创建了交换机，创建了队列，然后当发送者发送消息到交换机的时候交换机会进行广播，根据routing路由消息到不用的队列，进行不同的消息消费，需要用到的注解：

@Component实例化消费者类

@RabbitListener声明监听方法

@Queue创建队列

@Exchange创建交换机

@QueueBinding交换机和队列进行绑定

 

 

 

### 六、队列消息丢失问题

从实际来讲，队列中消息丢失是能的，例如生产者发送了10个消息到队列每个消息增加一条数据到数据库，结果最终数据库只有7条数据，这就是“消息丢失”，首先咱们要找到消息是从哪里丢失的，

有三个可能，

1：生产者丢失了消息，消息并没有成功发送到队列，

2：其次rabbit队列自己弄丢了，如果在发送消息时，mq意外宕机，也有可能造成丢失问题，

3：消费者丢失了数据，在消费者执行消息过程中取到消息后，消费者宕机了，队列认为消息已经消费了，

如何解决 ，

第一种生产者丢失消息，可使用confirm确认机制可以保证，就是发送消息确认一下消息，表明消息是否发送到队列

或者定义rpc回调接口 当消息执行的时候，可以回调一发送端的方法，证明消息已经被消费了

 

第二种队列自己丢失，可通过设置消息的持久化解决，消息发送后，是存储在内存中的，宕机肯定是造成丢失，然后在声明消息时可配置消息持久化到硬盘，服务宕机是无法影响硬盘的，数据不会丢失，交换机，队列，消息，都要设置持久化

 

第三种在消费者丢失

与spring整合后，消费者的监听方法监听到消息后会执行相应的业务逻辑，如果执行业务的过程中报错，会默认队列消息回滚就是将消息重新扔回到队列然后再次发送执行，但如果是业务或者数据本身除了问题，那么会导致再次报错，消息回滚，重而导致死循环，所以我们执行业务的试试一般要进行try catch异常捕捉，如果发生异常了，可以将发生异常的消息记录下来 而不是回滚到队列，那么就需要工作人员去查看这些失败的消息是什么了，解决好问题，然后重新执行下消息就可以

 

 

总结，如果以上三种方案都采用的话，在发生消息丢失的可能就很小了，如果还有，那就是很小几率的问题了，基本不会发生，可以用其他第三方处理，发送消息到队列的时候，在手动将消息像redis缓存，或者其他存储空间发送存储，消费者消费消息之后，在将redis中的消息进行标记，最后如果真的有消息未处理丢失，可以查看redis中是否有数据没有被标记，那这些数据就是丢失的消息可以排查原因为什么会被丢失，是否是数据本身问题等

 

### 七、高并发下队列抢购问题

在电商项目中，抢购模块是并发最高的，大批量请求并发在同一时间进入程序，这时候的业务逻辑比较多，要生成订单，并且sku表进行减库存操作，新增订单是新增数据，减sku库存是update操作，如果并发过多，会导致两个问题，1是并发多，数据库连接数不够，2：是操作同一条sku数据，行锁会导致sql无法并发执行，导致阻塞，所以我们在抢购的时候需要控制并发请求频率。在发送请求的时候，不直接操作数据库，而是将下单请求发送到队列，队列有削峰填谷的功能，把下单业务改成消费者监听的形式，这个时候，请求会一条一条去执行，控制了mysql的并发，同时在写sql减库存的时候，运用mysql锁update count=count-1 where count>0 在count大于0有库存的情况下载进行修改，根据改库存结果来决定订单是否创建，这样就保证了程序的稳定性，订单成功新增在去提示用户支付就可以

 

### 八、Spring boot 集合队列

1：生产者如何发送消息到队列

在生产者项目中导入starter-amqp包，因为队列交由spring整合了，配置yml配置文件,ip端口，账号密码等，在项目中用@autowire注入AmqpTemplate 这个队列的模板类，通过这个类的convertAndSend方法就可以发送消息了，调用后，可通过队列提供的web界面去查看，

2：消费者如果从队列监听消息并执行

在消费者项目中导入spring-ranbbit-boot包，配置yml信息，消费者类需要@Component声明，写接受消息的方法 @RabbitListener(queues="queue")注解 规定从哪个队列中拿消息

当然之能依次执行，例如队列中有10个消息，一次只能拿一个执行，执行完这个才能执行下一个消息，当然rabbit有很好的容错机制，当方法执行错误时，发送异常，就是把消息重新发送到系列，等待下一次执行，如果想提高消费者的执行效率，也可通过部署多个消费者来执行这个消息,