### 一、进程与线程的区别

进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源

### 二、如何实现多线程

Java多线程可以提高程序的并行，提高效率，可通过继承Thread类，实现Runnable接口，实现Callable来实现，通常建议实现runable 接口来实现多线程，因为类的机制是单继承多实现，所以实现runable线程，还可以继承别的类，拓展比较好，

继承runable 重写run方法，然后，调用线程的start启动线程就行，

### 三、多线程的使用场景

在项目中大并发的操作，例如群发邮件，迁移图片   记录日志等等

### 四、线程池如何使用

线程池可以限制线程最大的并发数量，保证程序的稳定运行，因为多线程虽然可以提高效率，但是也占用了cup的资源，如果线程开的过多，会导致cup消耗严重，所以在使用多线程的时候，要控制线程的最大并发，例如，我们要复制1w个文件，如果感觉单个单个复制太慢，可以多线程开提高效率，但如果开一万线程的话，肯定是不行，所以使用线城市来控制，可以保证最大的并发，一般使用定长线程池，newFixedThreadPool 首先创一个线程池 newFixedThreadPool a=new newFixedThreadPool(5)将上线设置5，然后有线程池去运行线程，这个时候，线程的最大并发会保持在5，执行完一个线程才能开始下一个线程 

### 五、 sleep，wait区别，如何唤醒线程

Sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

### 六、同步锁synchronized lock

Synchronized 和Lock 都是同步锁，可保证多线程兵发下，数据安全的问题，

首先先说什么是线程不安全。线程不安全的意思是指在多并发情况下对同一个对象数据进行操作，会导致冲突问题，例如一个线程查询出一条数据，count=3 ,另一个线程改变count=5，两个线程用到同一个数据，在不并发的时候，查询出来等于3，但线程一并发就等于5了，这就是线程不安全，

如果解决这个事情呢，就是控制当线程并发时候如果调用数据的时候，只能同步，不能并发，在方法上加上synchronized就可完成控制，synchronized的意思是当这个方法被调用后，其他线程就不能调用这个方法，必须等待这个方法执行完了，才可调动这个方法，保证了，数据不会冲突，这就是同步锁代码的底层，像hashMap就是线程不安全的，因为其方法都没有加锁控制，hashtable就是线程安全的，因为他的方法上都有synchronized修饰， 同理，vector和arraylist也是如此，当然不一定是线程必须安全，因为同步的执行方式肯定会执行降低程序执行效率，在线程没有并发调用公共变量时，是无需线程安全的，如果hashMap和arraylist很常用，就是因为虽然线程不安全，但是效率高

Lock也是锁的意思但与synchronized不同，lock是一个接口 synchronized是一个内置关键字 。Synchronized发生异常会自动释放锁，不会产生死锁 lock则需要手动调用unlock（）方法释放 容易造成死锁，所以lock一半都是在try catch 使用 在finally 释放锁，

而且lock是在数据冲突的时候在进行同步，如果这两次线程没有冲突是可以并行的，synchronized必须同步，因此，lock效率会比synchronized高些

### 七、Run和start的区别

Run方法是必须要重写的方法，在run方法中实现代码业务逻辑，start是开启线程

当调用start后，默认是等待cpu线程池调度，自动调用run方法执行

如果调用run方法，那么只是普通的调用方法，不能实现多线程并发的功能

### 八、线程池介绍

线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。

### 九、为什么要使用线程池

多线程运行时间，系统不断的启动和关闭新线程，cpu负荷成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。

### 十、线程池优势

（1）、降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；

（2）、提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；

（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。

（4）提供更强大的功能，延时定时线程池。

### 十一、线程池主要参数

a、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）

b、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。

c、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。

d、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。

e、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。

f、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。

### 十二、线程池种类

a、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）

b、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）

c、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。

d、：适用于执行延时或者周期性任务。