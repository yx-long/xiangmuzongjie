### 一、redis介绍（命令，数据类型，持久化）

Redis是一个缓存，key value的数据结构，最大的特点就是可以持久化，因此可作为nosql非关系数据库，最大的特点就是查询效率高，官方给出的最大并发可以读11w写8w每秒，我们在项目中通常把系统中查询频率较高的数据，放在缓存中，例如电商项目的首页中的导航栏，轮播图，推荐商品，历史浏览记录数据，几乎都是可用k-v这种结构的存储，因为都不需要条件模糊查询与分页，而且基本上不会变化，所以都放在redis中，redis数据类型有5个最常用的是String类型 hash,list zset set，三个特殊数据类型，bitmap,hyperlog，gospatial,还有一些常用的命令，丰富了redis的可用性，例如save持久化 select 切换库 expire设置过期时间，还有keys* 查看所有 等等，

Redis与其他缓存最大的区别就是可持久化的特性，也可以方便的做备份，一般采用两种模式，1：手动save持久化，2：设置持久策略，可以规定在固定时间内有多个数据放入，自动备份的机制，非常方便

这两者会生成一个dump.rdb文件，属于rdb存储

还有一个aop日志实时存储，会自动将执行的命令存储在日志文件中，可以自动实时存储，但性能略弱

### 二、redis如何在项目中使用

如果在项目中需要使用redis下，那么我们需要启动redis，然后在项目中导入redis的jar包，由于项目是boot+maven的技术结构，所以，导入redis的maven坐标，第二，需要在项目中yml文件配置redis跟spring整合的工具类redisTemplate配置redis的ip 端口，有密码，和最大连接上限等，然后在service使用时候直接使用@autowire注入就行，redis并不支持java数据类型，所以在存储java对象的时候，需要进行，对象的序列化成二进制 byte数组，或者序列化成json字符串进行存储

缓存数据如何与数据库进行同步

缓存是纯内存读取，效率很高，项目中把数据库中，经常被查询，且不需要条件查询和分页的数据放入缓存，

第一种：实时同步

但有些数据需要进行实时同步，例如数据库中的数据如果发生新增或更新，那么需要先要调用mapper进行操作数据库，然后发送一个mq的广播，告诉相关队列数据发生更新了，这样可以使用队列消费者监听到数据修改了，然后执行将数据存储到redis操作就可以，需要注意，设置redis数据的时候，注意要设置数据的过期时间，无特殊原因 不得永久保存一个数据

第二就是定时同步，例如，数据发生更新后第二天或者某个时间后才会查询使用，

可在规定时间执行定时器，更新数据即可

 

 

### 三、redis 是单线程的，为何查询效率这么快

完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

数据结构简单，对数据操作也简单

采用单线程，避免了不必要的上下文切换和竞争条件，因为cpu在多个进行中切换也会造成一定的性能延迟

使用多路I/O复用模型，非阻塞IO,执行完请求后，不会等待结果，而是执行下一个请求，因为是单线程，不能使用阻塞io会卡死。

### 四、redis事务

可使用multi 开启事务，输入命令后，用exex执行事务，或者DISCARD取消事务，这个时候，输入的redis命令就是一个事务整体！。要执行都执行，要失败都失败

Redis是弱事务类型，并没有mysql那中强事务 隔离级别 回滚策略等详细的事务控制策略，

### 五、缓存穿透

缓存穿透是只某次请求，肯定缓存中肯定没有，所以需要走数据库查询，缓存本身就是降低数据库查询的频率存在的，这样就失去缓存的意义，例如，在商品查询模块中，id为键 其他记录为值，分别存在redis和mysql中，他们是对应的，我们访问这个商品，肯定是传入商品的id去查询，这个时候，如果恶意访问，写一个肯定没有的商品id，那么redis中肯定是没有的，数据库中也没有，但肯定查询到db，这个时候就叫缓存穿透，

解决的方案:使用布隆过滤器bitmap

对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力，

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源

 

### 六、缓存雪崩

雪崩的概念就是有一次并发引起的集体宕机事件，缓存雪崩就是在在数据的集中查询的时间段，缓存集体失效，导致所有的缓存数据都需要从数据库中查询，导致db层压力过大，

解决方案，可以将每个缓存数据的过期时间，在指定时间之上，加上一个随机数生成的分钟数，确保每个数据的过期时间不一致就行了，避免同时失效

### 七、哨兵机制

哨兵机制是redis的集群方案，优于redis负责整个项目的数据读取，所以意外宕机后有很大的影响，所以集群哨兵就是保障redis运行的一个方案，首先准备两台redis，ip或者端口设置不同，避免冲突，例如6379 6380两台

1.配置slave(从库，奴隶的意思) 我们把6379作为主库，所以在conf中配置 slaveof:127.0.0.1:6380 , 意思是6380是6379 的从库，当主库6379发生数据改变时，会自动同步到从库，因此，两者的数据是一模一样的

2.搭建哨兵sentinel

sentinel.conf 配置文件中， 我们可以找到port 属性，这里是用来设置sentinel 的端口。

配置redis sentinel monitor mymaster 127.0.0.1 6380 2 意思是当redis当即后那个redis变成主库

3:哨兵的原理是 每秒都是想redis发送信息，如果消息得不到及时回应，那么就是宕机了，执行切换主库的操作

 

### 八、如何存放对象

Redis支持5个数据类型，List String Hash Set Zset，并不支持java中的包装数据类型，如果在java中，像redis中存入一个字符串，那么是可以的，因为redis也支持字符串，但是，如果向redis中存入一个自定义的java对象，那么是不支持的，

解决方案1：就将java中的对象实现 Serializable接口，然后将对象进行序列化一下，转为byte数据，对象在网络或者硬盘中传输的话，都要进行对象序列化，序列化之后就可以存储到redis了，当然，从redis取对象的时候，get出来的也是一个byte数组，如果想转为java对象，那么需要进行，反序列化，

解决方案2：将java中对象转为json字符串，然后在存储到redis，redis是支持字符串类型的value的，读取对象的时候，也需要将json字符串在转为json对象进行读取。

 

### 九、redis实现购物车

电商项目中的购物车都是用redis去做，因为购物车的特性，购物车的数据会频繁的移出和增入，买商品是增加到购物车，结算是移出商品，所以适合io效率比较高的redis去做，

购物车的功能：增加商品，删除商品，查询商品，修改数量，等

我们考虑的是两种模式，用户如果未登录去操作购物车，则从localstoreage本地存储，如果已登录就操作redis。

 

 

 

 

购物车的增加：用户登陆后，用户信息会存在token中，那么在点击新增购物车的时候，当购买的商品信息，提交到redis中，hash类型中，用userid为key

我们提交购物购买的skuid和购买数量num然后通过skuid 通过hash类型.hashkey（）方法，判断这个sku是否被购买过，如果购买过，合并购买数量，然后重新设置就可以，如果没有购买过。那么根据skuid查询出sku详细，然后将所有的详细数据，图片，价格，标题，规格等，存储到redis中

购物车的查询：

从token获取到登陆的用户id然后从缓存中获得所有的购买数据就可以，但查询出的结果是json格式，需要将json格式的数据转为java对象，用户的购物车数据商品信息有可能会发生变化，sku的价格，库存量，上下架信息都有可能变化，所以我们在展示之前，需要在实时的查询一下sku的最新数据信息，如果价格发生变化，那么根据新价格老价格提示用户价格发生了变化，库存发生变化后，要判断用户的购买数量是否大于当前库存，如果大于，也要进行提示，商品发生下架变化，那么需要将数据置灰，sku为不可购买状态，提示用户已下架

购物车的修改数量：当页面某个sku发生购买数量的变化时候，直接提交sku信息，和num数量，然后从hash对象中取得这个sku购买记录，将num覆盖后，重新设置到缓存就可以

购物车删除：直接提交要删除的skuid到后台，根据hash对象的api方法，找到这个购物车数据，进行删除就可以

 

 

 

 

### 十、Redis中如何修改商品价格后同步到购物车

购物车中保存的sku的一些信息，价格是购买时候的价格，当后台的商品价格发生更改后，没有直接修改购物车中的价格，但是会在页面展示购物商品的数据时候，会将购物车内所有的skuid重新请求一遍，如果该sku商品价格有修改，那么会页面会做一个价格对比展示 跟加入购物车时候，是涨价了，还是落价了，同时需要查询的还有上下架状态，还有可购买库存， 当页面展示购物车内数据时候，需要重新将sku的信息查询一遍，这个时候优先从缓存redis查询，如果redis中没有，那么就从商品微服务中查询一次，然后重新设置到redis缓存，这样的话该sku再次查询的时候，缓存redis中就有了

 

 

### 十一、Redis淘汰策略

noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。

allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。

volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。

allkeys-random: 所有key通用; 随机删除一部分 key。

volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。

volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

 

### 十二、Redis分布式锁

Redis可以在项目中充当分布式锁的功能，如果页面某个功能，需要进行加锁，那么可以使用sync关键字进行加锁，然后如果该项目分布式部署，那么sync只能锁住本项目的线程，无法跨项目加锁，这个时候，就需要用到分布式锁了，

首先，在程序开始的时候，在redis中通过setnx命令，设置一个变量，如果redis中没有这个变量，那么会创建成功，有的话会创建失败，（证明已经有人加锁在使用这个变量了）

当setnx 成功后，在设置一个过期时间， 超过这个过期时间，这个变量自动过期，锁也就会释放，这样可以避免程序宕机后，变量一直存在造成死锁问题

设置完成后，就可以执行业务逻辑了，当业务逻辑执行完之后，在delete删除这个变量，删除之后，下个线程就可以创建变量了 