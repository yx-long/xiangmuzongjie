#   总结概念

## 1.接口幂等?

##### 	概念

​		接口的幂等是系统对外的一种承诺,承诺只要调用成功,外部多次调用对系统的影响是一致的.

##### 	为什么要是有幂等

​		在网络波动时用户无意识多次点击会发送相同的请求,在重试机制下要保证数据的一致,不能出现重复数据,也不能多次调用相同接口.

##### 	如何实现幂等

​			有些接口本身就是幂等的比如查询接口,实在没有新增和修改时,删除也是幂等的他的最终结果也是删除.

​			在新增数据时采用唯一的单号,唯一的约束

### 	1.1什么是接口幂等性

   	 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性

## 2.spring mvc的执行流程? 

1.用户发送请求到DispatcherServlet
2.DispatcherServlet调用HandlerMapping根据请求url找到需要执行的处理器生成处理器执行链HandlerExecutionChain
3.DispatcherServlet通过HandlerAdapter(edaputer)调用处理器

4.执行处理器，返回ModelAndView给DispatcherServlet 

5.DispatcherServlet调用ViewResolver根据处理器返回的ModelAndView找到指定的视图返回一个可用的view实例。 

6.DispatcherServlet根据View渲染视图，并响应给用户。

## 3.spring mvc是什么时候把请求的参数映射到实体类的(其实这道题考的还是sringmvc的 运行原理,只不过是更细节的运行原理)?

- 1)用户发送请求至前段控制器DispatcherServlet;
- 2)DispatcherServlet收到请求后调用handlerMapping处理器映射器,请求获取handler;                                             
- 3)处理器映射器根据请求url找到具体的处理器,生成处理器对象及处理器拦截器一并返回给DispatcherServlet;
- 4)DispatcherServlet调用HandlerAdapater处理器适配器;
- 5)HandlerAdapater经过适配调用具体处理器;
- 6)Handler执行完成返回ModelAndView;
- 7)HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet;
- 8)DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析;
- 9)ViewResolver解析后返回集体View;
- 10)DispatcherServlet对View进行渲染视图
- 11)DispatcherServlet响应用户

## 4.mybatis的执行器有哪些?

​	SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

​	ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用,使用Statement对象。

​	BatchExecutor：执行update后，将所有sql都添加到批处理中，等待统一执行，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。

## 5.mybatis运行原理?

​    在MyBatis运行开始时需要先通过Resources加载全局配置文件.实例化SqlSessionFactoryBuilder构建器.
​	帮助SqlSessionFactory接口实现类DefaultSqlSessionFactory.
​	在实例化DefaultSqlSessionFactory之前需要先创建XmlConfigBuilder解析全局配置文件流,并把解析结果存放        	在Configuration中.
​	之后把Configuratin传递给DefaultSqlSessionFactory.到此SqlSessionFactory工厂创建成功.
​	由SqlSessionFactory工厂创建SqlSession.
​	每次创建SqlSession时,都需要由TransactionFactory创建Transaction对象,
​	同时还需要创建SqlSession的执行器Excutor,最后实例化DefaultSqlSession,传递给SqlSession接口.
​	根据项目需求使用SqlSession接口中的API完成具体的事务操作.
​	如果事务执行失败,需要进行rollback回滚事务.
​	如果事务执行成功提交给数据库.关闭SqlSession
​	到此就是MyBatis的运行原理

- mabatis运行加载全局配置文件后创建congfigurtion对象,根据congfiguration对象,创建SqlSessionFactory接口

- 然后调用openSession方法,创建SqlSession对象连接数据库 

- 根据传入的对象创建Executor对象,

- 通过Executor对象创建StatementHandler对象

- StatementHandler对sql进行预处理ParameterType进行绑定参数,使用ResultSetHandler进行结果集映射转换

- ParameterHandler对预处理后的statement使用TypeHandler进行参数绑定

- Statement.Execute执行sql

- ResultSetHandler将结果集的字段映射为java对象的属性值

- 获得到结果

  

- MyBatis在运行时加载并通过xmlconfiguration解析配置文件并把结果放在configuration中.configuration将结果提交给SqlSessionFactory,
   SqlSessionFactory再根据配置，获取一个SqlSession。 
  配置来源于两个地方，一处是配置文件，一处是Java代码的注解。
   SqlSession包含了执行sql所需要的所有方法， 可以通过SqlSession实例直接运行映射的sql语句， 
  完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。

  

## 6.mybatis如何自己实现一个分页插件(这道题考的其实还是mybatis的执行器和mybatis运行原理)?

​		Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

## 7.mybatis接口方法和xml标签如何映射?

​		mybatis是通过xml文件中mapper标签内的namespace属性来获得接口的全限定名来映射到xml

## 8.线程和进程的关系

线程在进程下进行

一个进程可以包含多个线程 

不同进程间数据很难共享

同一进程下不同线程间数据很易共享

进程要比线程消耗更多的计算机资源

进程间不会相互影响，一个线程挂掉将导致整个进程挂掉 

进程可以拓展到多机，线程适合多核

进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

进程使用的内存地址可以限定使用量

## 9.线程有哪些状态?

**新建(NEW)**：新创建了一个线程对象。

**就绪**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
**阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

**死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

## 10.线程的常用方法以及相似方法之间的区别(例如:sleep和yeild之类的)?

线程睡眠：sleep

​			让当前线程暂停一段时间，让出处理器资源，进入阻塞状态。当睡眠时间达到，该进程将会重新进入就绪状态。

线程让步：yeild

​		只有其他线程优先级与当前线程优先级相同或者更高，才会获得执行机会。

区别:

​	1.sleep()方法暂停线程不会理会优先级，而yield只会给优先级相同或者更高的线程。

​	2.sleep()方法让线程进入阻塞状态，而yield()方法让线程再次进入就绪状态，不会阻塞。

​	 可能该执行完yield()方法，立即再次获得处理器资源被执行。

​	3.sleep()方法声明抛出异常InterruptedException异常，所以调用sleep()方法时要么捕获该异常，

​	要么显式声明抛出异常。而yield()方法则没有声明抛出任何异常。

​	4.sleep()比yield()有更好的移植性，通常不建议使用yield()方法来控制并发线程的执行。



## 11.什么是线程安全?

线程安全就是在多线程访问时采用的加锁机制,当一个线程访问一个类的数据时就加锁其他线程不能访问只能等待当前线程访问完毕才能访问,这样不会造成数据污染和脏读发生.

## 12.sychronazed监听的是this可以解决线程安全的问题吗?

## 13.new String("abc")会创建几个对象,说一下原理(JVM内存模型)?

- 一个或两个
- 如果常量池中存在abc对象就使用不存在就创建这样就创建了两个对象

## 14.锁的膨胀(升级)过程?

- 偏向锁：只有一个线程进入临界区;

- 偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁;

- 轻量级锁：多个线程交替进入临界区;

- 重量级锁：多个线程同时进入临界区；

  

- 无锁（当前对象还没被使用）

- 偏向锁（当一个线程获取了锁就设置一个锁标识，这个标识存在对象头中,当有俩个以上的线程竞争锁的时候升级为轻量级锁）

- 轻量级锁(当一个线程自旋10次还是没有获取锁就升级为——》重量级锁）

## 15.如何创建自定义注解?

​	在接口的interface属上@符  

@Target 目标（我的理解就是：标明这个注解是干什么的，它要作用在哪些地方，相当于一个声明）
@Retention 保留（我的理解就是;它保留的时间，在什么时候是有效的）

## 16.说一下多态(如果只强调重写重载的话那基本就凉了)?

多态:

​	在java中 多态是指一种事务的多种状态

​	当继承关系发生后 我们用父类的引用指向子类的对象

​	当类实现接口 我们用接口的引用指向实现类对象

​	子级对象可以调用父级的部分特性 但是父级调用不到子级的特性

​	多态还包含重载和重写

好处：

- 提高了代码的复用性 ,维护性,扩展性

弊端

- 不能访问子类特有功能

重载:

- 重载是发生在同一类中,且方法名相同.
- 参数列表不同:
  				数据类型
        				个数不同
        				顺序不同
- 与返回值无关,与修饰符无关,
- 调用重载的方法由实际参数来决定的
- 重载是多态的一种体现

重写:

- 写是发生在继承关系中,当父类的方法无法满足子类的需求时,就在子类中重写父类的方法,重写也叫方法的覆盖
- 子类重写父类方法时,子类的返回值,方法名,参数列表必须完全一致,方法体不一致
- 子类不能重写父类中priavte修饰的和static修饰的方法
- 子类方法的访问权限不能小于父类;
- 子类方法不能声明比父类更大的异常.
- 重写也是java多态的一种体现,重载也是

## 17.treeset 如何去重?

​	treeset在排序中包含了去重,因为重复的key不会被添加到map中

## 18.Arraylist RandomAccess接口的作用?

RandomAccess 是一个标志接口，表明实现这个接口的 List 集合是支持快速随机访问的。也就是说，实现了这个接口的集合是支持 **快速随机访问** 策略的。

如果是**实现了这个接口的List，那么使用for循环的方式获取数据会优于用迭代器获取数据**。

## 19.序列化反序列化的作用?

将对象转换为字节序列是序列化，把字节序列转换为对象是反序列化，主要作用是把对象的字节序列永久的保存到硬盘上。

## 20.spring 如何为我们创建对象(生命周期)?

![dsa](D:\typora-user-images\dsa.png)

![gvfd](D:\typora-user-images\gvfd.png)

## 21.spring bean的作用域?

Singleton（单列）

Prototype（原型）

Request（请求）

Session

global-session

默认的是：单例 singleton

## 22.spring创建出来的对象(单例对象)是线程安全的吗?

不是线程安全的。但是单例bean也不表示就一定线程不安全，这要看bean中有没有多线程共享变量。如果都是线程私有数据，那也是线程安全的，反之就是不安全的！

## 23.如何保证spring的bean线程安全的呢?

在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。

## 24.threadlocal底层实现(这道题有可能会延伸出来 强弱软虚四种引用类型)?

ThreadLocal并不维护ThreadLocalMap（ThreadLocalMap是Thread的）并不是一个存储数据的容器，它只是相当于一个工具包，提供了操作该容器的方法，如get、set、remove等。而ThreadLocal内部类ThreadLocalMap才是存储数据的容器，并且该容器由Thread维护。 每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值（ ThreadLocalMap 是个弱引用类，内部 一个Entry由ThreadLocal对象和Object构成，

​		为什么要用弱引用呢？
如果是直接new一个对象的话，使用完之后设置为null后才能被垃圾收集器清理，如果为弱引用，使用完后垃圾收集器自动清理key，程序员不用再关注指针。			

强引用：不会被垃圾回收，宁肯抛出outofMemoryError错误也不会回收

软引用SoftReference：内存不足的时候会被优先回收，回收之后还是内存不足才会抛出outofmemory异常。适合用于缓存对象。

弱引用WeakReference：一个对象如果只有弱引用，那么就会被垃圾回收。常常用于hash表中，因为hash表允许存储java对象的引												用，如果用强引用的话只要hash表存在，那么键值对象就不会回收。如果某个hash表生命周期很长，键值又												多会很消耗内存。

虚引用： 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。

​				虚引用主要用于检测对象是否已经从内存中删除。

## 25.spring 是如何解决循环依赖的? 

- Spring通过三级缓存来解决循环依赖
- 为什么需要三级缓存，总而言之考虑到的是扩展性，预留扩展接口
- 循环依赖和AOP结合的时候，也能保证依赖的是代理对象，是通过SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference接口回调来实现的

## 26.mysql事物的隔离级别?

- Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

- Repeatable read (可重复读)：可避免脏读、不可重复读的发生。,7

- Read committed (读已提交)：可避免脏读的发生。

- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。

  

## 27.什么是赃读 幻读 重复读?

- 脏读：一个事务读取另外一个事务还没有提交的数据叫脏读。
- 通俗的讲，当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
- 不可重复读：不可重复读是指在同一个事务内，两次相同的查询返回了不同的结果。
- 在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。
- 幻读：幻读也是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。
- 指当事务不是独立执行时发生的一种现象，例如 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

## 28.哪个隔离级别会产生赃读?

- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

## 29.哪个隔离级别会产生幻读?

- Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
- Read committed (读已提交)：可避免脏读的发生。
- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

## 30.哪个会产生重复读?

- Read committed (读已提交)：可避免脏读的发生。
- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

## 31.查询语句的执行顺序? 

- FROM 子句：执行顺序为从后往前、从右到左。数据量较少的表尽量放在后面。
- WHERE子句：执行顺序为自下而上、从右到左。将能过滤掉最大数量记录的条件写在WHERE 子句的最右。
- GROUP BY：执行顺序从左往右分组，最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉。
- HAVING 子句：消耗资源。尽量避免使用，HAVING 会在检索出所有记录之后才对结果集进行过滤，需要排序等操作。
- SELECT子句：少用*号，尽量取字段名称。ORACLE 在解析的过程中, 通过查询数据字典将*号依次转换成所有的列名, 消耗时间。
- ORDER BY子句：执行顺序为从左到右排序，消耗资源。 

## 32.说一下你对分布式的理解?

分布式系统（distributed system） 是建立在网络之上的软件系统。

**内聚性：**是指每一个数据库分布节点高度自治，有本地的数据库管理系统。

**透明性：**是指每一个数据库分布节点对用户的应用来说都是透明的，看不出是本地还是远程。

在一个分布式系统中，一组独立的计算机展现给用户的是一个统一

的整体，就好像是一个系统似的。分布式系统作为一个整体对用户提供服务，而整个系统的内部的协作对用户来说是透明的，用户就像是

指使用一个Mysql一样，如：分布式Mysql中间件Mycat ，来处理大并发大数据量的构架。

## 33.说一下你对微服务的理解?

微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。

## 34.你们都有哪些微服务,服务之间是怎么划分的?

一般来说,微服务的划分应该松耦合,高内聚。松耦合就是服务与服务之间的关联性要减少,改动一个服务而不会影响另外一个服务。高内聚则是相关联的行为聚合再一起，避免修改一个功能需要修改多个服务。比如目前我们公司的理赔系统，

微服务是一个功能就是一个服务,修改其他服务不会影响当前服务的运行

## 35.你们用到了cloud的哪些组件?

· Eureka：服务注册于发现。

· Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。

· Ribbon(瑞本no)：实现负载均衡，从一个服务的多台机器中选择一台。

· Hystrix(黑死 chui 可 s)：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。

Zuul：网关管理，由 Zuul 网关转发请求给对应的服务

## 36.ribbon的负载均衡策略？

| 策略类                    | 命名               | 描述                                                         |
| :------------------------ | ------------------ | ------------------------------------------------------------ |
| RandomRule                | 随机策略           | 随机选择server                                               |
| RoundRobinRule            | 轮询策略           | 按照顺序选择server（ribbon默认策略）                         |
| RetryRule                 | 重试策略           | 在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server |
| BestAvailableRule         | 最低并发策略       | 逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server |
| AvailabilityFilteringRule | 可用过滤策略       | 过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值） |
| ResponseTimeWeightedRule  | 响应时间加权重策略 | 根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间 |
| ZoneAvoidanceRule         | 区域权重策略       | 综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server |

## 37.Eureka底层实现?

服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。

## 38.erurka挂了怎么办?

- 如果只有一个服务就只能重启服务
- 或者通过ribbon负载均衡多部署几个服务
- 如果经常挂掉可能是代码有问题

## 39.谈一下你对spring的理解?

Spring是一个轻量级的IOC和AOP容器框架.

是为java应用程序提供基础性服务的一套框架,目的是用于简化企业应用程序的开发,它使得开发者只需要关心业务需求.

常见的配置方式有三种:基于XML的配置,基于注解的配置,基于java的配置.

### 优点

1) 方便解耦,简化开发

2) AOP编程的支持 

3) 声明事务的支持 

4) 方便程序的测试 

5)方便集成各种优秀框架 

### 缺点

1)Spring明明一级的框架,却给人感觉大而全

2)Spring依赖反射,反射影响性能

3)使用门槛升高,入门Spring需要较长时间

spring是一个开放源代码的设计层面框架他解决的是业务逻辑层和其他各层的松耦合问题因此他将面向接口的变成思想贯穿整个系统应用Spring是全面的和模块化的。Spring有分层的体系结构这意味着你能选择使用它孤立的任何部分，他的架构仍然是内在稳定的Spring的主要目的是使Java EE易用和促进好的编程习惯他能通过接口而不是类促进好的编程习惯减少变成代价到几乎为零，使用Spring构建的应用程序易于单元测试。

## 40.动态代理/以及区别?

**JDK动态代理：**利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
**CGlib动态代理：**利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

**区别：**JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。

## 41.aspectj？

作为AOP的具体实现之一的AspectJ，它向Java中加入了连接点（Join Point）这个新概念，其实它也只是现存的一个Java概念的名称而已。它向Java语言中加入少许新结构：切点（pointcut）、通知（Advice）、类型间声明（Inter-typedeclaration）和方面（Aspect）。
切点和通知动态地影响程序流程，类型间声明则是静态的影响程序的类等级结构，而方面则是对所有这些新结构的封装.

## 42.mybatis 嵌套查询和嵌套结果有哪些区别?

```
<!--
    association：将关联查询信息映射到一个pojo对象中。
    collection：将关联查询信息映射到一个list集合中。
    -->
    <!--嵌套结果 只查一次-->
    <resultMap id="ordersResultMap" type="Orders">
        <id property="id" column="id"/>
        <result property="user_id" column="user_id"/>
        <result property="number" column="number"/>
        <result property="createtime" column="createtime"/>
        <result property="note" column="note"/>
        <!--<association property="user" javaType="User">-->
            <!--<id property="id" column="user_id"/>-->
            <!--<result property="username" column="username"/>-->
            <!--<result property="address" column="address"/>-->
        <!--</association>-->



     <!--嵌套查询 查2次-->
     <association property="user" select="mapper.UserMapper.mySelectByPrimary2" column="user_id">

   	 </association>
</resultMap>
    <select id="selectByPrimary2" resultMap="ordersResultMap">
        select o.*, u.username, u.address
        from orders o,
             user u
        where o.user_id = u.id
          and o.id = #{id}
    </select>
```

## 43.浏览器禁用掉cookie session还能用吗?怎么用?

## 44.如何解决mysql死锁？

MySQL有两种死锁处理方式：

1. 等待，直到超时（innodb_lock_wait_timeout=50s）。
2. 发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。

由于性能原因，一般都是使用死锁检测来进行处理死锁。

### 死锁检测

死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。

### 回滚

检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。

## 45.数据库如何做数据库优化?

**1、尽量避免使用select \***

我们需要哪些属性就取哪些，避免全盘接收。比如我们只需要查询id和name两个属性，那么我们可以使用SELECT id,name FROM TEACHER，尽量避免使用select * ,虽然有时效果一样，但效率不一样。

**2、union-all 代替union**

如果业务上没有特殊说明，可以考虑用UNION-ALL 替换UNION，因为UNION-ALL不会过滤重复数据，所执行效率要快于UNION,并且UNION可以自动排序，而UNION-ALL不会，这些细节往往都影响了数据库的性能。

**3、不使用NOT IN和like语句**

NOT IN和like“%aaa%”操作都不会使用索引，将进行全表扫描。可取的方法是NOT IN可以NOT EXISTS代替 。

**4、多使用limit**

当我们知道查询表只会有一条结果。在这种情况下，我们可以加上LIMIT 1，这样可以增加性能。MySQL数据库引擎会在找到一条数据后停止搜索，而不是占据cpu继续往下查直到查询表中的最后一条数据为止。

**5、读写分离**

在数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能

## 45.水平分表如何确定数据在哪个表里面?

## 46.sql如何优化?

- ​	l 避免在where中对字段进行null值得判断
- ​	l 避免使用 !=(不等于) 或<>（非等于）操作符
- ​	l 避免使用or(或)来连接条件
- ​	l 避免使用 in 和 not in
- ​	l 很多时候用 exists(yi ke sei s s)代替 in 是一个好的选择

## 47.mysql的explain(执行计划)?

## 48.聚集索引和非聚集索引?

​	聚集索引:聚集索引，来源于生活尝试。这中索引可以说是按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对					 这堆记录 进行 堆划分。即主要描述的是物理上的存储。

​	非聚集索引:聚集索引，也可以从生活中找到映射。非聚集索引强调的是逻辑分类。可以说是定义了一套存储规则，而需要有一块控件来维护这个规则，这个被称之为索引表。

## 区别：

​    聚集索引：可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了。
​    非聚集索引：把一个很大的范围，转换成一个小的地图。你需要在这个小地图中找你要寻找的信息的位置。然后通过这个位置，再去找你所需要的记录。

## 49.如何保证redis和mysql双写数据一致性?

## 50.redis数据类型(5种可能不是面试官想要的结果)?

- ​	string（字符串），
- ​	baihash（哈希），
- ​	ist（列表），
- ​	set（集合）
- ​	zset(sorted set：有序集du合)。

## 51.redis 持久化策略/以及区别?

​	redis有两种持久化方案：RDB和AOF
​	rdb类似一种数据的备份，就是将缓存中的数据冷备份到磁盘。需要恢复直接将改文件放到指定目录下即可。恢复速度快，数据丢失相	对较多。
​	aof就是日志记录，将该redis中发生的所有数据变化记录下来。恢复时就可以通过aof中的日志进行恢复。因为是解析日志，恢复速度	慢，但是数据丢失少。
​	如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

## 2.1 RDB

**优点：**

- 冷热备：RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷热备。
- 高性能：RDB对redis的对外读写能力影响有限，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO来进行RBD持久化即可。
- 快速恢复：相对AOF持久化机制来说，直接基于RDB的数据恢复更加快速。因为RDB文件就是redis的数据备份。

**缺点：**

- 数据丢失：如果采用RDB进行数据的备份，数据完整性没有AOF表现的那么好。一般来说RDB数据快照文件是每个5分钟进行一次备份。所以可能会造成5分钟的数据丢失。
- 海量数据阻塞主进程：尽管RDB仅仅是fork一个子进程来执行RDB快照数据文件的备份，如果数据文件特别大，可能导致主进程被阻塞数毫秒甚至是数秒。



## ***2.2 AOF***

**AOF持久化过程：**
1.追加写入:redis将每一条写命令以redis通讯协议添加至缓冲区aof_buf,这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命					令随后根据策略一次性写入磁盘，这样可以减少磁盘的I/O次数，提高性能。
2.同步命令到硬盘:当写命令写入aof_buf缓冲区后，redis会将缓冲区的命令写入到文件，redis提供了三种同步策略，由配置参数			
								appendfsync决定。
**优点：**

- 数据丢失更少：AOF日志文件每隔一秒会通过fsync刷新到磁盘。所以在默认情况下只会丢失一秒的数据。
- 性能开销小：AOF日志文件即使过大，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指令进行压缩。创建出一份需要恢复的数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，在交换新老日志文件即可。
- 灾难性误删除紧急恢复：AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要后台rewrite还没发生，那么就可以立即拷贝AOD文件，将最后一条flushall命令删除，然后再将该AOF文件放回去，然后恢复所有数据。

**缺点：**

- 性能较低：虽然AOF日志文件采用的是append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，但是相对于RDB持久化来说对redis性能影响还是较高的。每隔一秒执行一次fsync操作，这个开销还是很高的。（联想elasticsearch近实时性）

- 数据恢复慢：因为AOF是基于日志文件的数据恢复，所以相较于RDB数据备份来说数据恢复慢。

  ## RDB 的优缺点

  优点：
  1 适合大规模的数据恢复。
  2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

  ## AOF 的优缺点

  优点：数据的完整性和一致性更高
  缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

## 52.什么是restful风格?

一、概述

REST（英文：Representational State Transfer，简称REST）
一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。

二、什么是RESTful

REST 指的是一组架构（约束条件）和原则。满足这些（约束条件）和（原则）的应用程序或设计就是 RESTful。

三、restful有什么特点

1.每一个URI代表一种资源，独一无二
2.客户端和服务器之间，传递这种资源的某种表现层
3.客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

四、具体用例

RESTful架构风格规定，数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。

即：

GET（SELECT）：从服务器取出资源（一项或多项）。
POST（CREATE）：在服务器新建一个资源。
PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。
PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。
DELETE（DELETE）：从服务器删除资源。

五、结论

RESTful风格要求每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。
总之就是REST是一种写法上规范，获取数据或者资源就用GET，更新数据就用PUT，删除数据就用DELETE，然后规定方法必须要传入哪些参数，每个资源都有一个地址。

## 53.@Commpoent和@Bean的区别?

## 54.servlet生命周期?

## 55.limit优化(大表)?

## 56.如何查询mysql表中最后一条数据?

## 57.重复扣款问题(坑比较多)?

## 58.Redis主从复制的过程?

## 59.Redis怎么解决脑裂问题?

## 60.Redis分布式锁?

## 61.介绍一下哨兵机制?

## 62.查询的覆盖索引?

## 63.rabbitmq如何解决消息丢失问题?

## 64.mybatis一对多，多对多怎么实现?

## 65.mq怎么保证消息不会重复消费?

## 66.es读(通过id)/写数据的过程?

## 67.es搜索过程?

## 68.hashmap底层实现?

## 69.arrayList底层实现?

## 70.CAS是什么?

## 71.CAS的ABA问题?怎么解决?

## 72.volatile关键字的作用?

## 73synchronized的状态?

## 74DCL(双检索)单例会有线程安全的问题吗?

## 75创建线程的方式?

## 76线程池的状态?

## 77大表sql如何优化?

## 78自定义线程池的7个参数?

## 79SpringBoot的优点?

- ​	独立运行
- ​	简化配置
- ​	自动配置
- ​	无代码生成和XML配置
- ​	应用监控
- ​	上手容易

## 80SpringBoot自动配置原理?

​	点击核心注解 @SpringbootApplication

​	进入@EnableAutoConfiguration/yin nei bo a tou /这个接口 (开启自动配置)

​	接口上有一个@Import({AutoConfigurationImportSelector.class}) 注解

​	进入Import导入的类 搜索 SpringFactoriesLoader (Fa ke rui lou der)

​	在进入搜索的类 在第一行属性就可以看到源码位置 

## 81为什么使用springCloud框架(如果只是回答他的组件和他于springBoot的关系的话基本就凉了)?

## 82什么是微服务/微服务的意义?

​	什么是微服务？（熟悉的同学可以直接跳过）

简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把单艘航母理解为的单体应用（防御差，机动性不好），把航母战斗群（调度复杂，维护费用高）理解为微服务。

大部分的开发者经历和开发过单体应用，无论是传统的 Servlet + JSP，还是 SSM，还是现在的 SpringBoot，它们都是单体应用，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下：

- 部署成本高（无论是修改1行代码，还是10行代码，都要全量替换）
- 改动影响大，风险高（不论代码改动多小，成本都相同）
- 因为成本高，风险高，所以导致部署频率低（无法快速交付客户需求）

当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊

## 83项目中的难点/如何解决的?

## 84分布式中事务有哪些问题?

## 85二叉树?平衡二叉树?红黑树?Btree?B+tree?

## 86左旋(的过程/以及触发条件),右旋(的过程/以及触发条件),btree向上分裂?

## 87ReenTrantLock?

## 88限流(令牌桶,以及具体实现)?

## 89TCC补偿失败怎么处理?

## 90JVM内存模型?

**JDK 1.8之前：**

![img](https://img-blog.csdnimg.cn/2019040716163055.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzgxNzY4NQ==,size_16,color_FFFFFF,t_70)

**JDK 1.8 ：**

![img](https://img-blog.csdnimg.cn/20190407161653142.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzgxNzY4NQ==,size_16,color_FFFFFF,t_70)

- ​	堆
- ​	方法区
- ​	虚拟机栈
- ​	本地方法栈
- ​	程序计数器

## 91类的加载机制(双亲委派)?

​	**类加载机制：**

​	我们说了Class文件的结构，但是这些文件都要被加载到虚拟机中后才能使用，虚拟机如何加载这些Class文件。

​	虚拟机将描述类的数据从Class文件加载到内存，并对这些数据进行校验、解析以及初始化，最终形成可被虚拟机直接使用的java类	

​	型，这就是虚拟机的类加载机制。

​	在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。

## 92类的生命周期?

​	加载、连接、初始化、使用、卸载。其中连接又分为验证、准备、解析
如图：

![这里写图片描述](https://img-blog.csdn.net/20150806002943542)

## 93OOM会发生在什么地方?

## 94什么是垃圾?

## 95如果确定一个对象是垃圾(引用计数,根可达)?

## 96你了解的垃圾回收算法?

​	**垃圾回收算法**

​	了解了垃圾的确定方法后，我们将继续了解垃圾是怎么被回收的，即垃圾回收算法。在Java中主要有四中垃圾回收算法，

​	 分别是**标记清除算法**、**复制算法**、**标记整理算法** 和 **分代收集算法**。

## 97你知道的垃圾回收器?

​	了解GC之前我们首先要了解GC是要做什么的？顾名思义回收垃圾，什么是垃圾呢？

​	GC回收的垃圾主要指的是回收堆内存中的垃圾对象。

​	从根对象出发，所有被引用的对象，都是存活对象 其他对象都是垃圾对象。

## 98你们项目用的哪种垃圾回收器组合?

## 99spring boot的starter原理?

利用`starter`实现自动化配置只需要两个条件——`maven`依赖、配置文件，这里简单介绍下`starter`实现自动化配置的流程。

引入`maven`实质上就是导入`jar`包，`spring-boot`启动的时候会找到`starter` `jar`包中的`resources/META-INF/spring.factories`文

件，根据`spring.factories`文件中的配置，找到需要自动配置的类，

## 100如何自定义一个springboot的starter?

## 101java中的锁?

## 102Exrcutors创建线程池有什么缺点?

## 103jvm?

## 104gc?

​	GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存

回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动

回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。

## 105BIO和NIO说一下？

## 106Nginx的反向代理？

​	反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

## 107你用到过那些设计模式，在什么场景下用到的?

​	每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。

(1) MVC模式,在J2EE项目开发中主要用在表示层框架中，很好解决视图和流程控制。在项目中采用的Struts、WebWork等框架。

(2) DAO模式,在项目开发中主要用在数据层，封装数据的访问操作，为业务层提供数据服务。

(3) IoC模式,在项目开发中业务层有大量对象，他们之间存在依赖关系，可以使用IoC模式减少他们之间的代码耦合，提高系统的可扩展	   	 性。实际项目中使用的Spring框架来实现业务组件的装配。

(4) Observer模式，在Servlet的监听器中应用到了观察者模式。

(5) singleton单例模式和Factory工厂模式结合使用在项目中无需使用者了解过多的细节就可获取有关的对象实例。比如Hibernate项目中	 通过SessionFactory来获取Session。

(6) bridge模式，在项目中使用JDBC驱动访问数据库。

## 108为什么要用Eureka?

## 109Eureka的自我保护机制?

## 110Eureka如何保证数据一致性?

​	![img](https://pic4.zhimg.com/80/v2-c920338e7c455b72f54be4a32661ff9b_720w.jpg)

​	服务注册中心不可能是单点的，一定会有一个集群，那么集群中的服务注册信息如何在集群中保持一致的呢？

​	首先要明确的是 Eureka 是**弱数据一致性**的。

​	下面从2个方面来说明：

1. 什么是弱数据一致性
2. Eureka 是如何同步数据的

## 111Zuul怎么实现路由的?

## 112Zuul怎么拦截请求的?

## 113Feign怎么做的请求转发的?

## 114Git冲突怎么解决?

​	产生：多个开发者同时使用或者操作git中的同一个文件，最后在依次提交commit和推送push的时候，第一个操作的是可以正常提交	

​	的，而之后的开发者想要执行pull（拉）和pull（推）操作的时候，就会报冲突异常conflict。

​	解决：保留自己修改的数据，同时保留别人的数据信息；同时pull代码之前，需要手动解决冲突之后再作提交。

## 115什么是fastDFS，在项目中怎么用的?

​	FastDFS是什么?

​	适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、 TFS（淘宝）等。但他们都是真正处	理大数据的分布式文件系统架构，文件动辄几百兆甚至几十G，对 文件会进行切割等处理，处理小图片文件有杀鸡用牛刀之嫌。且性能	也不够好
于是淘宝的余庆先生开发了一个轻量级、高性能的开源分布式文件系统FastDFS。用纯C语言开发，功 能丰富：

- 文件存储
- 文件同步
- 文件访问（上传、下载）
- 存取负载均衡
- 在线扩容

## 116介绍一下Tcc?

## 117Tcc补偿失败怎么处理?

## 118mybatis和hibernate的区别?

## 119重复订单的问题?

​	问题描述：用户下订单购买，因为各种原因（网络卡，快递点击等）重复提交2个或者以上一模一样的订单，由于是同时提交的，第一	个订单执行扣款生成订单未完成时候，第二个已经进来了，导致付一笔钱购买了2次或多次商品 解决方案：

​	1、缓存lock，缓存此用户的操作行为，注意紧紧缓存操作的标志，下次进入判断此标志是否存在，存在即不进入数据库事务

​	2、应用程序application lock，和1相比，会阻塞其他用户的正常行为

​	3、模仿银行扣款机制，数据表建一个随机唯一标志，每次请求带上这个标志，操作的同时进行修改这个标志

​	4、应用程序生成唯一标志，数据库做字段的唯一索引

​	5、扣款为负数的事务进行回滚

​	6、使用事务的隔离级别

​	7、使用redis的incr控制用户的并发数，memcache的add也可以实现这种效果，memcached借助cas

### **如何避免?**

​		①当进入商品详情页时，去生成一个全局唯一ID（可用雪花算法）；

　　②将这个全局唯一ID和订单信息传给服务器；

　　③判断这个ID对应的订单号存在，则直接返回；

　　④生成订单号，保存订单信息；

## 120TCP三次握手四次挥手?

​	说到 TCP 协议，相信大家都比较熟悉了，对于 TCP 协议总能说个一二三来，但是 TCP 协议又是一个非常复杂的协议，其中有不少细节	点让人头疼点。本文就是来说说这些头疼点的，浅谈一些 TCP 的疑难杂症。那么从哪说起呢？当然是从三次握手和四次挥手说起啦，	可能大家都知道 TCP 是三次交互完成连接的建立，四次交互来断开一个连接，那为什么是三次握手和四次挥手呢？反过来不行吗？

## 121熔断怎么处理?

## 122git分支?

## 

## 123静态化的具体流程?

## 124那有过哪些和第三方系统对接的经验?

## 125svn是怎么搭建的?

## 126nginx几台，怎么搭建的?

## 127商品超卖的情况怎么解决?

## 128你在项目中遇到过什么印象比较深的问题吗？你是怎么解决的？解决的思路是什么?

## 129如果你的经理给了你一个需求让你实现，你需要考虑到什么?

## 130创建多个订单的时候怎么保证线程安全的?

## 131订单的幂等性怎么保证?

## 132创建订单怎么同时减少库存?

## 133如何防止页面被人恶意攻击?